两大使用场景---ThreadLocal的用途
    典型场景1: 每个线程需要一个独享的对象(通常是工具类,典型需要使用的类有SimpleDateFormat和Random)
        每个Thread内有自己的实例副本，不共享
        比喻:教材只有一本，一起做笔记有线程安全问题。复印后没问题
    典例场景2: 每个线程内需要保存全局变量(例如在拦截器中获取用户信息),可以让不同方法直接使用，避免参数传递的麻烦
        实例:当前用户信息需要被线程内所有方法共享
            一个比较繁琐的解决方案是把user作为参数层层传递,从service-1()传到service-2()，再从service-2()传到service-3(),
            依次类推，但是这样做会导致代码冗余且不易维护
            简单演化可以使用userMap进行存储，但是存在多个线程使用，会造成线程不安全
            当多线程同时工作时，需要抱着线程安全，可以用synchronized,也可以用ConcurrentHashMap,但是无论用什么，都会对性能有所影响。
            更好的办法是使用ThreadLocal,这样无需synchronized,可以在不影响性能的情况下，也无需层层传递参数，就可达到保存当前
            线程对应的用户信息的目的。
        方法：
            用ThreadLocal保存一些业务内容(用户权限信息、从用户系统获取到的用户名、userID等)。
            这些信息在同一个线程内相同，但是不同的业务线程使用的业务内容是不相同的。
            在线程生命周期内，都通过这个静态ThreadLocal实例的get()方法取得自己set过的那个对象，避免了将这个对象(例如user对象)作为
            参数传递的麻烦。
            强调的是同一个请求内(同一个线程内)不同方法间的共享。
            不需要重写initialValue()方法，但是必须手动调用set()方法。
        利用共享的Map    
            可以用static的ConcurrentHashMap，把当前线程的ID作为key，把user作为value来保存，这样可以做到线程间的隔离，但是依然有性能影响。
    总结：ThreadLocal的两个作用
        1.让某个需要用到的对象在线程间隔离(每个线程都有自己的独立的对象)
        2.在任何方法中可以轻松获取到该对象
    场景一: initialValue
        在ThreadLocal第一次get的时候把对象给初始化出来，对象的初始化时机可以由我们控制。    
    场景二：set
        如果需要保存到ThreadLocal里的对象的生成时机不由我们随意控制，例如拦截器生成的用户信息，用ThreadLocal.set直接放到我们的ThreadLocal中去，以便后续使用。    
使用ThreadLocal带来的好处
   1.达到线程安全  
   2.不需要加锁，提高执行效率
   3.更高效地利用内存、节省开销：相比于每个任务都新建一个SimpleDateFormat，显然用ThreadLocal可以节省内存和开销。       
   4.免去传参的繁琐：无论是场景一的工具类，还是场景二的用户名，都可以在任何地方直接通过ThreadLocal拿到，再也不需要每次都传同样的参数。ThreadLocal使得代码
   耦合度更低，更优雅。
ThreadLocal详解---ThreadLocal原理
   
   
                
    